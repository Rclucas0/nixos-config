#+title: NixOS Flake Configuration
#+author: Riley Lucas
#+description: What NixOS is and my configuration


* TABLE OF CONTENTS :toc@4:
- [[#what-is-nixos][What Is NixOS]]
- [[#useful-nix-commands][Useful Nix Commands]]
- [[#what-are-nix-flakes][What Are Nix Flakes]]
- [[#my-current-nixos-configuration-using-nix-flakes][My Current NixOS Configuration Using Nix Flakes]]
  - [[#flakenix-configuration][Flake.nix Configuration]]
    - [[#configurationnix-configuration][Configuration.nix Configuration]]
      - [[#bluetoothnix-file][Bluetooth.nix File]]
      - [[#virt-managernix][Virt-manager.nix]]
      - [[#syspackagesnix-file][SysPackages.nix File]]
    - [[#dwmnix-file][Dwm.nix File]]
      - [[#dwm-configh-configuration][Dwm config.h Configuration]]
  - [[#homenix-configuration][Home.nix Configuration]]
- [[#user-dotfiles][User Dotfiles]]
  - [[#starship-config][Starship Config]]
  - [[#sxhkd-config][Sxhkd Config]]
- [[#and-i-can-link-to-other-org-files-in-this-repo][And I can Link To Other Org Files In This Repo]]

* What Is NixOS

- NixOS is a declarative system unlike most systems that you normally see to day which are imperative
- Only difference is that the system configurations other then user customization is all done in one file and is rebuilt on each install
- The configuration is written in a functional programming language called Nix
- The Nix programming uses nix to create and nix package which is then used to

* Useful Nix Commands

- sudo nixos-rebuild switch/test
  * This command will reinstall the entire system and add a new entry to boot loader if used switch, test will do the same other than adding it to boot loader

- sudo nixos-rebuild switch/ test --flake ./path/to/flake.nix
  * Rebuilds the system with a flake rather than default configuration.nixos

- sudo nix-collect-garbage --delete-older-than 15d
  * Will remove unused packages and boot loader entries

* What Are Nix Flakes

From [[https://zero-to-nix.com/concepts/flakes][Zero to Nix]]

- A Nix flake is a directory with a flake.nix and flake.lock at the root that outputs Nix expressions that others can use to do things like build packages, run programs, use development environments, or stand up NixOS systems. If necessary, flakes can use the outputs of other flakes as inputs.

* My Current NixOS Configuration Using Nix Flakes

- This is my current set up of NixOS using a flake to setup the main system
- I am also using emacs org-mode to set up most of this config and what you are reading now


#+CAPTION: My Dwm NixOS Flake Setup
#+NAME: GruvBox Dwm
[[./1mon-gruvbox-dwm.png]]

** Flake.nix Configuration

#+begin_src nix :tangle ./flake.nix
{
  description = "My Nix Flake Configuration With Dwm";

  inputs = {
    nixpkgs.url = "github:nixos/nixpkgs/nixos-23.11";

#    home-manager = {
#      url = "github:nix-community/home-manager";
#      inputs.nixpkgs.follows = "nixpkgs";
#    };
  };

  outputs = { self, nixpkgs }:
  let
    system = "x86_64-linux";

    pkgs = import nixpkgs {
      inherit system;
      config = { allowUnfree = true; };
    };


  in {
    nixosConfigurations = {
      nixos = nixpkgs.lib.nixosSystem {
        specialArgs = { inherit system; };
        modules = [
          ./profiles/personal-dwm/configuration.nix
#          inputs.home-manager.nixosModules.default
        ];
      };
    };
  };
}
#+end_src

*** Configuration.nix Configuration

#+begin_src nix :tangle ./profiles/personal-dwm/configuration.nix
{ config, pkgs, ... }:

{
  imports =
    [
      ../../system/hardware-configuration.nix
#      inputs.home-manager.nixosModules.default
      ../../system/syspkgs.nix
      ../../system/bluetooth.nix
      ../../system/virt-manager.nix
      ../../user/wm/dwm.nix

    ];

  # Bootloader.
  boot.loader.systemd-boot.enable = true;
  boot.loader.efi.canTouchEfiVariables = true;

  networking.hostName = "nixos";

  # Enable networking
  networking.networkmanager.enable = true;

  # Set your time zone.
  time.timeZone = "America/Chicago";

  # Select internationalisation properties.
  i18n.defaultLocale = "en_US.UTF-8";

  i18n.extraLocaleSettings = {
    LC_ADDRESS = "en_US.UTF-8";
    LC_IDENTIFICATION = "en_US.UTF-8";
    LC_MEASUREMENT = "en_US.UTF-8";
    LC_MONETARY = "en_US.UTF-8";
    LC_NAME = "en_US.UTF-8";
    LC_NUMERIC = "en_US.UTF-8";
    LC_PAPER = "en_US.UTF-8";
    LC_TELEPHONE = "en_US.UTF-8";
    LC_TIME = "en_US.UTF-8";
  };

  # Enable the X11 windowing system.
  services.xserver = {
    enable = true;
    libinput = {
      enable = true;
      mouse = {
        accelProfile = "flat";
      };
    };
  };

  # Enable the KDE Plasma Desktop Environment.
  services.xserver.displayManager.sddm.enable = true;
  services.xserver.desktopManager.plasma5.enable = true;

  # Configure keymap in X11
  services.xserver = {
    layout = "us";
    xkbVariant = "";
  };

  # Enable Flakes And Nix Commands
  nix.settings.experimental-features = [ "nix-command" "flakes" ];

  # Enable sound with pipewire.
  sound.enable = true;
  hardware.pulseaudio.enable = false;
  security.rtkit.enable = true;
  services.pipewire = {
    enable = true;
    alsa.enable = true;
    alsa.support32Bit = true;
    pulse.enable = true;
  };

  users.users.rileyl = {
    isNormalUser = true;
    description = "Riley Lucas";
    extraGroups = [ "networkmanager" "wheel" "libvirtd" "dialout" ];
    packages = with pkgs; [

    ];
  };

#  home-manager = {
#    extraSpecialArgs = { inherit inputs; }
#    users = {
#      "rileyl" = import ./home.nix;
#    };
#  };

  system.stateVersion = "23.11";
}
#+end_src

**** Bluetooth.nix File

#+begin_src nix :tangle ./system/bluetooth.nix
{config, pkgs, ...}:
{
  # Enable Bluetooth and Start on Boot
  hardware.bluetooth.enable = true;
  hardware.bluetooth.powerOnBoot = true;
  services.blueman.enable = true;
}
#+end_src

**** Virt-manager.nix

#+begin_src nix :tangle ./system/virt-manager.nix
{config, pkgs, ...}:
{
  # Virt-Manager
  virtualisation.libvirtd.enable = true;
  programs.virt-manager.enable = true;
}
#+end_src

**** SysPackages.nix File

#+begin_src nix :tangle ./system/syspkgs.nix
{config, pkgs, ...}:

{
  # Enable Dconf
  programs.dconf.enable = true;

   # Allow unfree packages
  nixpkgs.config.allowUnfree = true;

  # Enable Steam
  programs.steam = {
    enable = true;
    remotePlay.openFirewall = true;
    dedicatedServer.openFirewall = true;
  };

  # Enable and Start emacs daemon
  services.emacs = {
    enable = true;
    package = pkgs.emacs;
  };

  environment.systemPackages = with pkgs; [
    alacritty aspell
    brave btop bibata-cursors
    discord dunst dmenu
    dracula-icon-theme dracula-theme
    fd flameshot
    gparted gcc gruvbox-gtk-theme gruvbox-dark-icons-gtk git gimp gnumake gnome.adwaita-icon-theme
    htop
    ispell
    kitty
    libsForQt5.kdenlive libsForQt5.qt5ct lsd lxappearance
    mpv
    newsboat neofetch neovim nitrogen
    pavucontrol papirus-icon-theme picom prismlauncher
    qemu_full
    rofi rose-pine-icon-theme ripgrep
    starship sxhkd slock steam st sweet
    tela-circle-icon-theme thonny thunderbird
    vim
    yt-dlp
    xfce.thunar
    obs-studio
  ];
}
#+end_src

*** Dwm.nix File

#+begin_src nix :tangle ./user/wm/dwm.nix
{config, pkgs, ...}:

{
  # Enable Dwm
  services.xserver.windowManager.dwm.enable = true;
  services.xserver.windowManager.dwm.package = pkgs.dwm.overrideAttrs {
    src = ./dwm;
  };

  environment.systemPackages = with pkgs; [
    (slstatus.overrideAttrs (_:{ src = ./dwm/slstatus;}))
  ];
}
#+end_src

**** Dwm config.h Configuration

#+begin_src c :tangle ./user/wm/dwm/config.def.h
/* appearance */
static const unsigned int borderpx  = 2;        /* border pixel of windows */
static const unsigned int gappx     = 5;        /* gaps between windows */
static const unsigned int snap      = 32;       /* snap pixel */
static const int showbar            = 1;        /* 0 means no bar */
static const int topbar             = 0;        /* 0 means bottom bar */
static const char *fonts[]          = { "monospace:size=15" };
static const char dmenufont[]       = "monospace:size=10";
static const char col_gray1[]       = "#222222";
static const char col_gray2[]       = "#444444";
static const char col_gray3[]       = "#bbbbbb";
static const char col_gray4[]       = "#eeeeee";
static const char col_cyan[]        = "#005577";
static const char col_yell[]        = "#F1D357";
static const char col_pink[]        = "#EE6D85";
static const char col_teal[]        = "#38A89D";
static const char col_gruv_yell[]           = "#b57614";
static const char col_gruv_orng[]           = "#d65d0e";
static const char col_gruv_redL[]           = "#fb4934";
static const char *colors[][3]      = {
	/*               fg         bg         border   */
	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
	[SchemeSel]  = { col_gray4, col_gruv_redL,  col_gruv_redL  },
};

/* tagging */
static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };

static const Rule rules[] = {
	/* xprop(1):
	 *	WM_CLASS(STRING) = instance, class
	 *	WM_NAME(STRING) = title
	 */
	/* class      instance    title       tags mask     isfloating   monitor */
	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
};

/* layout(s) */
static const float mfact     = 0.55; /* factor of master area size [0.05..0.95] */
static const int nmaster     = 1;    /* number of clients in master area */
static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */

static const Layout layouts[] = {
	/* symbol     arrange function */
	{ "[]=",      tile },    /* first entry is default */
	{ "><>",      NULL },    /* no layout function means floating behavior */
	{ "[M]",      monocle },
};

/* key definitions */
#define MODKEY Mod4Mask
#define TAGKEYS(KEY,TAG) \
	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },

/* helper for spawning shell commands in the pre dwm-5.0 fashion */
#define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }

/* commands */
static char dmenumon[2] = "0"; /* component of dmenucmd, manipulated in spawn() */
static const char *dmenucmd[] = { "dmenu_run", "-m", dmenumon, "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
static const char *termcmd[]  = { "kitty", NULL };

static const Key keys[] = {
	/* modifier                     key        function        argument */
	{ MODKEY,                       XK_d,      spawn,          {.v = dmenucmd } },
	{ MODKEY,                       XK_Return, spawn,          {.v = termcmd } },
	{ MODKEY,                       XK_b,      togglebar,      {0} },
	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
	{ MODKEY,                       XK_p,      incnmaster,     {.i = -1 } },
	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
	{ MODKEY|ShiftMask,             XK_Return, zoom,           {0} },
	{ MODKEY,                       XK_Tab,    view,           {0} },
	{ MODKEY,                       XK_q,      killclient,     {0} },
	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
	{ MODKEY,                       XK_space,  setlayout,      {0} },
	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
	{ MODKEY,                       XK_minus,  setgaps,        {.i = -1 } },
	{ MODKEY,                       XK_equal,  setgaps,        {.i = +1 } },
	{ MODKEY|ShiftMask,             XK_equal,  setgaps,        {.i = 0  } },
	TAGKEYS(                        XK_1,                      0)
	TAGKEYS(                        XK_2,                      1)
	TAGKEYS(                        XK_3,                      2)
	TAGKEYS(                        XK_4,                      3)
	TAGKEYS(                        XK_5,                      4)
	TAGKEYS(                        XK_6,                      5)
	TAGKEYS(                        XK_7,                      6)
	TAGKEYS(                        XK_8,                      7)
	TAGKEYS(                        XK_9,                      8)
	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
};

/* button definitions */
/* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
static const Button buttons[] = {
	/* click                event mask      button          function        argument */
	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
	{ ClkTagBar,            0,              Button1,        view,           {0} },
	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
};


#+end_src

** Home.nix Configuration

#+begin_src nix :tangle ./home.nix
{ config, pkgs, ... }:

{
  # Home Manager needs a bit of information about you and the paths it should
  # manage.
  home.username = "rileyl";
  home.homeDirectory = "/home/rileyl";

  # This value determines the Home Manager release that your configuration is
  # compatible with. This helps avoid breakage when a new Home Manager release
  # introduces backwards incompatible changes.
  #
  # You should not change this value, even if you update Home Manager. If you do
  # want to update the value, then make sure to first check the Home Manager
  # release notes.
  home.stateVersion = "23.11"; # Please read the comment before changing.

  # The home.packages option allows you to install Nix packages into your
  # environment.
  home.packages = [
    # # Adds the 'hello' command to your environment. It prints a friendly
    # # "Hello, world!" when run.
    # pkgs.hello

    # # It is sometimes useful to fine-tune packages, for example, by applying
    # # overrides. You can do that directly here, just don't forget the
    # # parentheses. Maybe you want to install Nerd Fonts with a limited number of
    # # fonts?
    # (pkgs.nerdfonts.override { fonts = [ "FantasqueSansMono" ]; })

    # # You can also create simple shell scripts directly inside your
    # # configuration. For example, this adds a command 'my-hello' to your
    # # environment:
    # (pkgs.writeShellScriptBin "my-hello" ''
    #   echo "Hello, ${config.home.username}!"
    # '')
  ];

  # Home Manager is pretty good at managing dotfiles. The primary way to manage
  # plain files is through 'home.file'.
  home.file = {
    # # Building this configuration will create a copy of 'dotfiles/screenrc' in
    # # the Nix store. Activating the configuration will then make '~/.screenrc' a
    # # symlink to the Nix store copy.
    # ".screenrc".source = dotfiles/screenrc;

    # # You can also set the file content immediately.
    # ".gradle/gradle.properties".text = ''
    #   org.gradle.console=verbose
    #   org.gradle.daemon.idletimeout=3600000
    # '';
  };

  # Home Manager can also manage your environment variables through
  # 'home.sessionVariables'. If you don't want to manage your shell through Home
  # Manager then you have to manually source 'hm-session-vars.sh' located at
  # either
  #
  #  ~/.nix-profile/etc/profile.d/hm-session-vars.sh
  #
  # or
  #
  #  ~/.local/state/nix/profiles/profile/etc/profile.d/hm-session-vars.sh
  #
  # or
  #
  #  /etc/profiles/per-user/rileyl/etc/profile.d/hm-session-vars.sh
  #
  home.sessionVariables = {
    # EDITOR = "emacs";
  };

  # Let Home Manager install and manage itself.
  programs.home-manager.enable = true;
}

#+end_src

* User Dotfiles

- These are the files that are not controlled by the flake or by the base NixOS config
- Soon will be moved to a home-manager setup

** Starship Config

#+begin_src toml :tangle ~/.config/starship.toml
add_newline = true

[character]
error_symbol = "[➜](bold red)"
success_symbol = "[➜](bold blue)"

[package]
disabled = false
#+end_src

** Sxhkd Config

#+begin_src bash :tangle ~/.config/sxhkd/sxhkdrc
super + BackSpace
	pkill -USR1 -x sxhkd

super + {_}{w,a,Return,e}
	{brave,st,kitty,emacsclient -c -a 'emacs'}

super + shift + {_}{d}
	{rofi -show drun}

alt + {_}{d,s,r,h,m,g}
	{discord,steam,dmenu_run,flatpak run com.heroicgameslauncher.hgl,prismlauncher,gimp}

alt + shift + {_}{p,Return}
	{pavucontrol,thunar}

ctrl + {_}{p}
	{flameshot gui}
#+end_src

* And I can Link To Other Org Files In [[./user/README.org][This Repo]]
